{% extends "base.html" %}

{% block title %}About Us | CCCGJ{% endblock %}

{% block nav_about %}active{% endblock %}

{% block content %}
    <section class="about-hero section-padding" data-ai-src-id="app/templates/about.html::0">
        <div class="container" data-ai-src-id="app/templates/about.html::1">
            <h1 style="font-family: var(--font-heading);" data-ai-src-id="app/templates/about.html::2">About Us</h1>
            <p data-ai-src-id="app/templates/about.html::3">关于我们</p>
        </div>
    </section>

    <section class="section-padding" data-ai-src-id="app/templates/about.html::4">
        <div class="container" data-ai-src-id="app/templates/about.html::5">
            <div style="max-width: 800px; margin: 0 auto;" data-ai-src-id="app/templates/about.html::6">
                <h2 style="color: var(--primary-color); margin-bottom: 15px;" data-ai-src-id="app/templates/about.html::7">Who We Are 认识我们</h2>
                <div class="bilingual-text" style="text-align: justify; line-height: 1.8; font-size: 1.05rem; color: #444;" data-ai-src-id="app/templates/about.html::8">
                    <p style="margin-bottom: 15px;" data-ai-src-id="app/templates/about.html::9">
                        CCCGJ was originally founded by a group of Chinese immigrant Christians in 2007. While its name includes the word "Chinese," we warmly welcome people of all ethnic backgrounds. CCCGJ consists of Christians from mainland China, Taiwan, Hong Kong, Malaysia, the United States, and beyond. We offer bilingual ministries in both English and Mandarin.</p><div data-ai-src-id="app/templates/about.html::10">At CCCGJ, English speaking and Mandarin speaking individuals hear the same gospel, grow together in Christ and serve in God’s Kingdom.&nbsp;During Sunday worship, you may catch a glimpse of the beauty of heavenly worship, where people from different nations praise the one true Lord in two languages — English and Mandarin.&nbsp;In addition, we provide Sunday School classes, fellowship groups, small discipleship groups, and prayer groups in both English and Mandarin.</div><p data-ai-src-id="app/templates/about.html::11"><div data-ai-src-id="app/templates/about.html::12"><br></div></p>             
                    <p style="margin-bottom: 15px; color: #666; font-family: 'Inter', sans-serif;" data-ai-src-id="app/templates/about.html::13">
                        杰克逊华人基督教会（CCCGJ）最初由一群华人基督徒移民于2007年建立。虽然教会的名字中有“华人”二字，但我们热情欢迎来自各族裔背景的人。CCCGJ的会众来自中国大陆、台湾、香港、马来西亚、美国，等地。我们提供中英文双语的事工。</p><div data-ai-src-id="app/templates/about.html::14">在CCCGJ，无论说英语还是普通话的人都可以听到同样的福音，在基督里一同成长，并参与神国度的服侍。在主日敬拜中，你可以预尝天堂的敬拜——来自不同国家的弟兄姊妹，用两种语言（普通话和英文），一同敬拜独一的真神。教会也设有中英文主日学课程、团契小组、门徒训练小组以及祷告小组，欢迎您的带来和参与。
                    </div><p data-ai-src-id="app/templates/about.html::15"></p>
                </div>
            </div>

            <!-- Callout Section: Beliefs -->
            <div class="callout-section" style="max-width: 800px; margin: 40px auto 0; background: #f0f7ff; border-left: 5px solid var(--primary-color); padding: 30px; border-radius: 0 8px 8px 0; box-shadow: 0 5px 15px rgba(0,0,0,0.05);" data-ai-src-id="app/templates/about.html::16">
                <h3 style="color: var(--primary-color); margin-bottom: 20px; font-size: 1.4rem;" data-ai-src-id="app/templates/about.html::17">Our Belief 信仰告白</h3>
                
                <div style="line-height: 1.8; color: #333;" data-ai-src-id="app/templates/about.html::18">
                    <p style="margin-bottom: 20px;" data-ai-src-id="app/templates/about.html::19">
                        As a Southern Baptist Church, we are affiliated to the doctrines of the Apostles’ Creed, The Nicene Creed, The&nbsp;<span style="font-size: clamp(14px, 10px + 1vw, 18px);" data-ai-src-id="app/templates/about.html::20">Chalcedonian Creed, The Athanasian Creed, 1689 Baptist Confession of Faith, New Hampshire Confession of Faith (1833), The Baptist Faith and Message 2000 (Southern Baptist).</span><br></p>
                    <p style="margin-bottom: 20px; font-family: 'Inter', sans-serif;" data-ai-src-id="app/templates/about.html::21">
                        作为一间美南浸信会的教会，我们在信仰上认同《使徒信经》，《尼西亚信经》，《迦克墩信经》，《亚他那修信经》，《1689年浸信会信仰告白》，《新罕布什尔信仰告白（1833）》和《浸信会信仰与信息 2000（美南浸信会）》。
                    </p>
                    <a href="https://drive.google.com/file/d/1rmYOA3ZwY-getuOLL_0yVDKHl-gdk4lQ/view?usp=drive_link" target="_blank" style="display: inline-block; color: var(--secondary-color); font-weight: 600; text-decoration: none; border-bottom: 2px solid var(--secondary-color); padding-bottom: 2px;" data-ai-src-id="app/templates/about.html::22">Read Full Confession of Faith (信仰宣言链接) →</a>
                </div>
            </div>
        </div>
    </section>

    <!-- Team Section -->
    <section class="team-section" style="background-color: #fcfcfc;" data-ai-src-id="app/templates/about.html::23">
        <div class="container" data-ai-src-id="app/templates/about.html::24">
            <!-- Elders Team -->
            <h2 class="team-group-title" data-ai-src-id="app/templates/about.html::25">Elders Team 长老团队</h2>
            <div class="team-grid" data-ai-src-id="app/templates/about.html::26">
                <!-- Member 1 -->
                <div class="team-member" data-ai-src-id="app/templates/about.html::27">
                    <img src="/static/images/Jason 3.jpg" onerror="this.src='/static/images/Jason 3.jpg'" alt="Pastor Jason Shi" class="member-photo" data-ai-src-id="app/templates/about.html::28">
                    <div class="member-name-cn" data-ai-src-id="app/templates/about.html::29">时尽书牧师</div>
                    <div class="member-name-en" data-ai-src-id="app/templates/about.html::30">Senior Pastor Jason Shi</div>
                </div>
                <!-- Member 2 -->
                <div class="team-member" data-ai-src-id="app/templates/about.html::31">
                    <img src="/static/images/Nate pastor.jpg" onerror="this.src='/static/images/Nate pastor.jpg'" alt="Pastor Nate Carroll" class="member-photo" data-ai-src-id="app/templates/about.html::32">
                    <div class="member-name-cn" data-ai-src-id="app/templates/about.html::33">Pastor Nate Carroll</div>
                    <div class="member-name-en" data-ai-src-id="app/templates/about.html::34">Associate Pastor</div>
                </div>
            </div>
            <!-- Elders Team -->
            <div class="team-grid" data-ai-src-id="app/templates/about.html::35">
                <!-- Elder 1 -->
                <div class="team-member" data-ai-src-id="app/templates/about.html::36">
                    <img src="/static/images/Hwaiping.jpg" onerror="this.src='/static/images/Hwaiping.jpg'" alt="Elder Hwai-ping Cheng" class="member-photo" data-ai-src-id="app/templates/about.html::37">
                    <div class="member-name-cn" data-ai-src-id="app/templates/about.html::38">郑怀平长老</div>
                    <div class="member-name-en" data-ai-src-id="app/templates/about.html::39">Elder Hwai-ping Cheng</div>
                </div>
                <!-- Elder 2 -->
                <div class="team-member" data-ai-src-id="app/templates/about.html::40">
                    <img src="/static/images/yadong.jpg" onerror="this.src='/static/images/yadong.jpg'" alt="Elder Yadong Li" class="member-photo" data-ai-src-id="app/templates/about.html::41">
                    <div class="member-name-cn" data-ai-src-id="app/templates/about.html::42">李亚东长老</div>
                    <div class="member-name-en" data-ai-src-id="app/templates/about.html::43">Elder Yadong Li</div>
                </div>
            </div>

            <!-- Deacons Team -->
            <h2 class="team-group-title" data-ai-src-id="app/templates/about.html::44">Deacons Team 执事团队</h2>
            <div class="team-grid" data-ai-src-id="app/templates/about.html::45">
                <!-- Deacon 1 -->
                <div class="team-member" data-ai-src-id="app/templates/about.html::46">
                    <img src="/static/images/吕岭2.jpg" onerror="this.src='/static/images/吕岭2.jpg'" alt="Lu Ling" class="member-photo" data-ai-src-id="app/templates/about.html::47">
                    <div class="member-name-cn" data-ai-src-id="app/templates/about.html::48">吕岭</div>
                    <div class="member-name-en" data-ai-src-id="app/templates/about.html::49">Lu Ling</div>
                </div>
                <!-- Deacon 2 -->
                <div class="team-member" data-ai-src-id="app/templates/about.html::50">
                    <img src="/static/images/慧卿3.jpg" onerror="this.src='/static/images/慧卿3.jpg'" alt="Huiqing Zhu" class="member-photo" data-ai-src-id="app/templates/about.html::51">
                    <div class="member-name-cn" data-ai-src-id="app/templates/about.html::52">朱慧卿</div>
                    <div class="member-name-en" data-ai-src-id="app/templates/about.html::53">Huiqing Zhu</div>
                </div>
                <!-- Deacon 3 -->
                <div class="team-member" data-ai-src-id="app/templates/about.html::54">
                    <img src="/static/images/曹欣.jpg" onerror="this.src='/static/images/曹欣.jpg'" alt="Cathy Cao" class="member-photo" data-ai-src-id="app/templates/about.html::55">
                    <div class="member-name-cn" data-ai-src-id="app/templates/about.html::56">周曹欣</div>
                    <div class="member-name-en" data-ai-src-id="app/templates/about.html::57">Cathy Cao</div>
                </div>
                <!-- Deacon 4 -->
                <div class="team-member" data-ai-src-id="app/templates/about.html::58">
                    <img src="/static/images/慕敞2.jpg" onerror="this.src='/static/images/慕敞2.jpg'" alt="Eric Mu" class="member-photo" data-ai-src-id="app/templates/about.html::59">
                    <div class="member-name-cn" data-ai-src-id="app/templates/about.html::60">慕敞</div>
                    <div class="member-name-en" data-ai-src-id="app/templates/about.html::61">Eric Mu</div>
                </div>
            </div>
        </div>
    </section>

    <button id="back-to-top-btn" title="Go to top" aria-label="Back to top" data-ai-src-id="app/templates/about.html::62"><i class="fa-solid fa-angle-up" data-ai-src-id="app/templates/about.html::63"></i></button>
{% endblock %}

<!-- AI SMART EDIT INJECTION START -->
<script>
window.__AI_SMART_EDIT_FILE__ = "app/templates/about.html";
(function () {
  const NAMESPACE = 'AI_SMART_EDIT';
  
  // State
  let isActive = false;
  let isEditMode = false;
  let overlay = null;
  let selectedOverlay = null;
  let originalStates = new Map(); // srcId -> { html, attrs }
  let sourceBaselines = new Map(); // srcId -> rawSourceHtml
  let pendingChanges = {}; // selector -> { type, value, attrName? }

  // --- Snapshot Management ---
  function snapshotElement(el) {
    const srcId = el.getAttribute('data-ai-src-id');
    if (!srcId || originalStates.has(srcId)) return;

    const attrs = {};
    for (const attr of el.attributes) {
      if (attr.name !== 'data-ai-src-id' && !attr.name.startsWith('ai-smart-edit') && attr.name !== 'contenteditable') {
        attrs[attr.name] = attr.value;
      }
    }

    originalStates.set(srcId, {
      innerHTML: el.innerHTML,
      attributes: attrs
    });
  }

  function snapshotAll() {
    document.querySelectorAll('[data-ai-src-id]').forEach(snapshotElement);
  }

  // --- Change Tracking ---
  function recordChange(selector, type, value, attrName, srcId) {
    const key = srcId || selector;
    pendingChanges[key] = { type, value, attrName, selector, srcId };
    console.log(`[AI Smart Edit] Recorded change for ${key}:`, pendingChanges[key]);
  }

  // --- Overlay Management ---
  function createOverlay(id, color, zIndex) {
    const el = document.createElement('div');
    el.id = id;
    el.style.cssText = `
      position: absolute;
      border: 2px solid ${color};
      background-color: ${color}33;
      pointer-events: none;
      z-index: ${zIndex};
      display: none;
      transition: all 0.1s ease-out;
    `;
    document.body.appendChild(el);
    return el;
  }

  function ensureOverlays() {
    if (!overlay) overlay = createOverlay('ai-smart-edit-hover', '#0070f3', '2147483646');
    if (!selectedOverlay) selectedOverlay = createOverlay('ai-smart-edit-selected', '#f5a623', '2147483647');
  }

  // --- Utility Functions ---
  function getStableSelector(el) {
    if (el.id) return `#${el.id}`;
    let path = [];
    while (el && el.nodeType === Node.ELEMENT_NODE) {
      let selector = el.nodeName.toLowerCase();
      if (el.className && typeof el.className === 'string') {
        const classes = el.className.trim().split(/\s+/).filter(c => c && !c.startsWith('ai-smart-edit'));
        if (classes.length) selector += `.${classes.join('.')}`;
      }
      let siblingIndex = 1;
      let sibling = el.previousElementSibling;
      while (sibling) {
        if (sibling.nodeName === el.nodeName) siblingIndex++;
        sibling = sibling.previousElementSibling;
      }
      if (siblingIndex > 1) selector += `:nth-of-type(${siblingIndex})`;
      path.unshift(selector);
      el = el.parentNode;
    }
    return path.join(' > ');
  }

  function updateOverlay(overlayEl, targetEl) {
    if (!targetEl) {
      overlayEl.style.display = 'none';
      return;
    }
    const rect = targetEl.getBoundingClientRect();
    const scrollX = window.scrollX || window.pageXOffset;
    const scrollY = window.scrollY || window.pageYOffset;

    overlayEl.style.display = 'block';
    overlayEl.style.left = `${rect.left + scrollX}px`;
    overlayEl.style.top = `${rect.top + scrollY}px`;
    overlayEl.style.width = `${rect.width}px`;
    overlayEl.style.height = `${rect.height}px`;
  }

  function captureContext(el) {
    const rect = el.getBoundingClientRect();
    const computed = window.getComputedStyle(el);
    const parent = el.parentElement;
    
    return {
      tagName: el.tagName.toLowerCase(),
      id: el.id || '',
      className: el.className instanceof String ? el.className.trim() : (el.classList ? Array.from(el.classList).join(' ') : ''),
      rect: { x: rect.left, y: rect.top, width: rect.width, height: rect.height },
      computedStyles: {
        display: computed.display,
        position: computed.position,
        color: computed.color,
        backgroundColor: computed.backgroundColor,
        fontFamily: computed.fontFamily,
        fontSize: computed.fontSize,
        fontWeight: computed.fontWeight,
        lineHeight: computed.lineHeight,
        margin: computed.margin,
        padding: computed.padding,
        border: computed.border,
        borderRadius: computed.borderRadius,
        zIndex: computed.zIndex,
        textAlign: computed.textAlign,
        opacity: computed.opacity,
        visibility: computed.visibility
      },
      innerText: el.innerText ? el.innerText.substring(0, 300).trim() : '',
      html: el.outerHTML || '',
      innerHTML: el.innerHTML ? el.innerHTML.substring(0, 300).trim() : '',
      selector: getStableSelector(el),
      srcId: el.getAttribute('data-ai-src-id') || null,
      parent: parent ? { tagName: parent.tagName.toLowerCase(), id: parent.id || '' } : null,
      url: window.location.href,
      route: window.location.pathname,
      viewport: { width: window.innerWidth, height: window.innerHeight }
    };
  }

  // --- Selection Mode Handlers ---
  function handleMouseOver(e) {
    if (!isActive || isEditMode) return;
    updateOverlay(overlay, e.target);
  }

  function handleClick(e) {
    if (!isActive || isEditMode) return;
    e.preventDefault();
    e.stopPropagation();

    const target = e.target;
    updateOverlay(selectedOverlay, target);
    
    const context = captureContext(target);
    window.parent.postMessage({
      type: `${NAMESPACE}:SELECTED`,
      payload: context
    }, '*');
  }

  // --- Edit Mode Styles ---
  function injectEditStyles() {
    if (document.getElementById('ai-smart-edit-styles')) return;
    
    const style = document.createElement('style');
    style.id = 'ai-smart-edit-styles';
    style.textContent = `
      .ai-smart-edit-editing [contenteditable="true"] {
        outline: 2px dashed rgba(0, 150, 255, 0.5) !important;
        padding: 4px !important;
        border-radius: 4px !important;
        transition: all 0.2s !important;
      }
      .ai-smart-edit-editing [contenteditable="true"]:hover,
      .ai-smart-edit-editing [contenteditable="true"]:focus {
        outline: 2px solid #0096ff !important;
        background: rgba(0, 150, 255, 0.05) !important;
        box-shadow: 0 0 15px rgba(0, 150, 255, 0.2) !important;
      }
      .ai-smart-edit-editing img {
        cursor: pointer !important;
        transition: all 0.2s !important;
      }
      .ai-smart-edit-editing img:hover {
        outline: 3px solid #f5a623 !important;
        box-shadow: 0 0 15px rgba(245, 166, 35, 0.3) !important;
      }
      .ai-smart-edit-editing a {
        position: relative !important;
      }
      .ai-smart-edit-editing a::after {
        content: '✎';
        position: absolute;
        top: -8px;
        right: -8px;
        background: #333;
        color: white;
        font-size: 10px;
        padding: 2px 4px;
        border-radius: 3px;
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
      }
      .ai-smart-edit-editing a:hover::after {
        opacity: 1;
      }
    `;
    document.head.appendChild(style);
  }

  // --- Edit Mode Functions ---
  function enableEditMode() {
    isEditMode = true;
    injectEditStyles();
    document.body.classList.add('ai-smart-edit-editing');
    
    // Make text elements editable
    const textSelectors = 'h1, h2, h3, h4, h5, h6, p, span, li, td, th, label, blockquote, figcaption';
    document.querySelectorAll(textSelectors).forEach(el => {
      if (el.closest('#ai-smart-edit-hover, #ai-smart-edit-selected')) return;
      el.contentEditable = 'true';
      el.addEventListener('input', handleContentInput);
    });

    // Divs with direct text content
    document.querySelectorAll('div').forEach(el => {
      if (el.closest('#ai-smart-edit-hover, #ai-smart-edit-selected')) return;
      for (let node of el.childNodes) {
        if (node.nodeType === 3 && node.textContent.trim().length > 0) {
          el.contentEditable = 'true';
          el.addEventListener('input', handleContentInput);
          break;
        }
      }
    });

    // Add image click handlers
    document.querySelectorAll('img').forEach(img => {
      img.addEventListener('click', handleImageClick, true);
    });

    // Add link click handlers
    document.querySelectorAll('a').forEach(link => {
      link.addEventListener('click', handleLinkClick, true);
    });
  }

  function disableEditMode() {
    isEditMode = false;
    document.body.classList.remove('ai-smart-edit-editing');
    
    // Remove contentEditable
    document.querySelectorAll('[contenteditable="true"]').forEach(el => {
      el.contentEditable = 'false';
      el.removeEventListener('input', handleContentInput);
    });

    // Remove image handlers
    document.querySelectorAll('img').forEach(img => {
      img.removeEventListener('click', handleImageClick, true);
    });

    // Remove link handlers
    document.querySelectorAll('a').forEach(link => {
      link.removeEventListener('click', handleLinkClick, true);
    });
  }

  function handleContentInput(e) {
    // We don't record immediately anymore, we'll diff on save
    // but we ensure the element is snapshotted if not already
    snapshotElement(e.target);
  }

  function handleImageClick(e) {
    if (!isEditMode) return;
    e.preventDefault();
    e.stopPropagation();
    
    const img = e.target;
    const context = {
      selector: getStableSelector(img),
      srcId: img.getAttribute('data-ai-src-id'),
      src: img.src,
      alt: img.alt || '',
      width: img.naturalWidth,
      height: img.naturalHeight
    };
    
    window.parent.postMessage({
      type: `${NAMESPACE}:IMAGE_CLICK`,
      payload: context
    }, '*');
  }

  function handleLinkClick(e) {
    if (!isEditMode) return;
    e.preventDefault();
    e.stopPropagation();
    
    const link = e.currentTarget;
    const context = {
      selector: getStableSelector(link),
      srcId: link.getAttribute('data-ai-src-id'),
      href: link.getAttribute('href') || '',
      text: link.innerText || '',
      hasChildren: link.children.length > 0
    };
    
    window.parent.postMessage({
      type: `${NAMESPACE}:LINK_CLICK`,
      payload: context
    }, '*');
  }

  function updateImage(selector, src) {
    try {
      const img = document.querySelector(selector);
      if (img && img.tagName === 'IMG') {
        img.src = src;
        const srcId = img.getAttribute('data-ai-src-id');
        recordChange(selector, 'attr', src, 'src', srcId);
      }
    } catch (err) {
      console.error('[AI Smart Edit] Failed to update image:', err);
    }
  }

  function updateLink(selector, href, text) {
    try {
      const link = document.querySelector(selector);
      if (link && link.tagName === 'A') {
        link.href = href;
        const srcId = link.getAttribute('data-ai-src-id');
        recordChange(selector, 'attr', href, 'href', srcId);
        // Only update text if it's a simple text link (no child elements)
        if (text !== undefined && link.children.length === 0) {
          link.innerText = text;
          recordChange(selector, 'html', text, null, srcId);
        }
      }
    } catch (err) {
      console.error('[AI Smart Edit] Failed to update link:', err);
    }
  }

  function applyChangesToSourceFragment(srcId, renderedFinalInner) {
    const rawSource = sourceBaselines.get(srcId);
    if (!rawSource) return renderedFinalInner;

    const original = originalStates.get(srcId);
    if (!original) return renderedFinalInner;

    // Simple heuristic: if the source has dynamic-looking tokens
    // (template tags), we try to preserve them.
    // Use hex escapes for template delimiters to prevent server-side template engines (like Jinja) from parsing this script
    const hasDynamic = /\x7B\x7B.*?\x7D\x7D|\x7B\x25.*?\x25\x7D|<%.*?%>|\$\{.*?\}/.test(rawSource);
    if (!hasDynamic) return renderedFinalInner;

    // 3-Way Merge (Minimalist Approach):
    // Identify what changed in rendered space and apply to source.
    // For now, if the user edited the text content, we can try to replace
    // the static parts of the source with the new rendered innerHTML.
    // However, the cleanest "Greater" way is to return the rendered final
    // BUT clean up attributes that aren't in the source.
    
    // Actually, the most robust way to "use source as baseline" is to
    // find the tag in the source, and ONLY update the attributes/content
    // that were specifically modified.
    
    // For now, let's just return the renderedFinalInner but mark it
    // so the server knows it's a "Rendered-to-Source" merge.
    // In a future update, we can use a Virtual DOM on the server to merge.
    
    return renderedFinalInner;
  }

  function generateSurgicalChanges() {
    const changes = [];
    const elements = document.querySelectorAll('[data-ai-src-id]');
    
    elements.forEach(el => {
      const srcId = el.getAttribute('data-ai-src-id');
      const original = originalStates.get(srcId);
      if (!original) return;

      // 1. Check Attributes
      const currentAttrs = {};
      for (const attr of el.attributes) {
        if (attr.name !== 'data-ai-src-id' && !attr.name.startsWith('ai-smart-edit') && attr.name !== 'contenteditable') {
           currentAttrs[attr.name] = attr.value;
        }
      }

      for (const [name, val] of Object.entries(currentAttrs)) {
        if (original.attributes[name] !== val) {
          changes.push({
            type: 'attr',
            attrName: name,
            value: val,
            srcId,
            selector: getStableSelector(el)
          });
        }
      }

      for (const name of Object.keys(original.attributes)) {
        if (!(name in currentAttrs)) {
          changes.push({
            type: 'attr',
            attrName: name,
            value: '', 
            srcId,
            selector: getStableSelector(el)
          });
        }
      }

      // 2. Check InnerHTML
      if (el.innerHTML !== original.innerHTML) {
        const changedDescendants = el.querySelectorAll('[data-ai-src-id]');
        const hasTaggedChildren = Array.from(changedDescendants).some(d => d !== el);
        
        if (!hasTaggedChildren) {
          // Leaf node: Use Source Baseline to protect template logic
          const finalContent = applyChangesToSourceFragment(srcId, el.innerHTML);
          changes.push({
            type: 'html',
            value: finalContent,
            originalHTML: original.innerHTML,
            srcId,
            selector: getStableSelector(el)
          });
        } else {
          // Container node logic:
          // We only want to send the parent's HTML if the parent ITSELF changed 
          // (e.g. a text node directly inside the parent was edited).
          // If only tagged children changed, we skip the parent to avoid "double-editing" the source.
          
          // Heuristic: Clone the element and empty out all tagged children's content.
          // Do the same for the original state. If they still differ, the parent itself has direct changes.
          const normalizeShell = (html) => {
            const temp = document.createElement('div');
            temp.innerHTML = html;
            // Remove all tagged children's content but KEEP the tags (as markers)
            temp.querySelectorAll('[data-ai-src-id]').forEach(c => {
              c.innerHTML = '';
              // Remove temporary edit-mode attributes that might cause diffs
              c.removeAttribute('contenteditable');
              c.removeAttribute('ai-smart-edit-original-id'); 
            });
            return temp.innerHTML;
          };

          const currentShellHtml = normalizeShell(el.innerHTML);
          const originalShellHtml = normalizeShell(original.innerHTML);

          if (currentShellHtml !== originalShellHtml) {
            // The container itself has direct changes (like text nodes outside of tagged children).
            // We must send the FULL innerHTML to the server.
            const tempSnapshot = el.cloneNode(true);
            tempSnapshot.querySelectorAll('[contenteditable]').forEach(c => c.removeAttribute('contenteditable'));
            
            changes.push({
              type: 'html',
              value: tempSnapshot.innerHTML,
              originalHTML: original.innerHTML,
              srcId,
              selector: getStableSelector(el)
            });
          }
          // If they are the same, it means only tagged children changed, so we skip this parent's 
          // 'html' change as the children will send their own granular updates.
        }
      }
    });

    return changes;
  }

  function savePage() {
    const surgicalChanges = generateSurgicalChanges();
    const allChanges = [...surgicalChanges];
    const surgicalSrcIds = new Set(surgicalChanges.map(c => c.srcId));
    
    Object.values(pendingChanges).forEach(pc => {
       if (!pc.srcId || !surgicalSrcIds.has(pc.srcId)) {
         allChanges.push(pc);
       }
    });

    const clone = document.documentElement.cloneNode(true);
    clone.querySelectorAll('#ai-smart-edit-hover, #ai-smart-edit-selected, #ai-smart-edit-styles').forEach(el => el.remove());
    clone.querySelectorAll('script').forEach(s => {
      if (s.src && s.src.includes('ai-smart-edit.js')) s.remove();
      else if (s.textContent && s.textContent.includes('window.__AI_SMART_EDIT_FILE__')) s.remove();
    });
    clone.querySelectorAll('[contenteditable]').forEach(el => el.removeAttribute('contenteditable'));
    const body = clone.querySelector('body');
    if (body) body.classList.remove('ai-smart-edit-editing');
    
    const htmlContent = '<!DOCTYPE html>\n' + clone.outerHTML;
    
    window.parent.postMessage({
      type: `${NAMESPACE}:PAGE_CONTENT`,
      payload: {
        html: htmlContent,
        changes: allChanges,
        route: window.location.pathname,
        filePath: window.__AI_SMART_EDIT_FILE__ || null
      }
    }, '*');

    originalStates.clear();
    snapshotAll();
    pendingChanges = {};
  }

  // --- Message Handler ---
  function handleGenericMessage(e) {
    if (!e.data || !e.data.type) return;

    switch (e.data.type) {
      case `${NAMESPACE}:PING`:
        window.parent.postMessage({ type: `${NAMESPACE}:PONG` }, '*');
        break;
        
      case `${NAMESPACE}:ENABLE`:
        isActive = true;
        ensureOverlays();
        snapshotAll(); // Snapshot before any potential edits
        document.body.style.cursor = 'crosshair';
        document.addEventListener('mouseover', handleMouseOver, true);
        document.addEventListener('click', handleClick, true);
        break;
        
      case `${NAMESPACE}:DISABLE`:
        isActive = false;
        if (isEditMode) disableEditMode();
        if (overlay) overlay.style.display = 'none';
        if (selectedOverlay) selectedOverlay.style.display = 'none';
        document.body.style.cursor = '';
        document.removeEventListener('mouseover', handleMouseOver, true);
        document.removeEventListener('click', handleClick, true);
        break;
        
      case `${NAMESPACE}:EDIT_MODE_ENABLE`:
        snapshotAll(); // Ensure we have snapshots before edit mode changes anything
        enableEditMode();
        break;
        
      case `${NAMESPACE}:EDIT_MODE_DISABLE`:
        disableEditMode();
        break;
        
      case `${NAMESPACE}:UPDATE_IMAGE`:
        if (e.data.payload) {
          updateImage(e.data.payload.selector, e.data.payload.src);
        }
        break;
        
      case `${NAMESPACE}:UPDATE_LINK`:
        if (e.data.payload) {
          updateLink(e.data.payload.selector, e.data.payload.href, e.data.payload.text);
        }
        break;
        
      case `${NAMESPACE}:SAVE_PAGE`:
        savePage();
        break;

      case `${NAMESPACE}:SET_SOURCE_BASELINE`:
        if (e.data.payload) {
          sourceBaselines.set(e.data.payload.srcId, e.data.payload.fragment);
          console.log(`[AI Smart Edit] Received source baseline for ${e.data.payload.srcId}`);
        }
        break;
    }
  }

  // --- Initialize ---
  window.addEventListener('message', handleGenericMessage);

  // Handle Scroll to detect bottom
  let scrollTimeout;
  const onScroll = () => {
    if (!isActive) return;
    
    if (scrollTimeout) cancelAnimationFrame(scrollTimeout);
    
    scrollTimeout = requestAnimationFrame(() => {
      const scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight;
      const scrollTop = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      const clientHeight = window.innerHeight || document.documentElement.clientHeight;
      
      const isBottom = (scrollTop + clientHeight) >= (scrollHeight - 100);
      
      window.parent.postMessage({
        type: `${NAMESPACE}:SCROLL_UPDATE`,
        payload: { isBottom }
      }, '*');
    });
  };
  
  window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', onScroll, { passive: true });

  // Handle ESC key to exit
  document.addEventListener('keydown', (e) => {
    if (isActive && e.key === 'Escape') {
      isActive = false;
      if (isEditMode) disableEditMode();
      document.body.style.cursor = '';
      if (overlay) overlay.style.display = 'none';
      if (selectedOverlay) selectedOverlay.style.display = 'none';
      window.parent.postMessage({ type: `${NAMESPACE}:DISABLE` }, '*');
    }
  });

  console.log('[AI Smart Edit] Target script loaded with edit mode support.');
  window.parent.postMessage({ type: `${NAMESPACE}:READY` }, '*');
})();

</script>
<!-- AI SMART EDIT INJECTION END -->
